<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>堆</title>
    <link href="/2025/06/21/%E5%A0%86/"/>
    <url>/2025/06/21/%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<p>今天来讲一下 堆（优先队列）。</p><h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>求最值问题。</p><h1 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h1><p>模板题：<a href="https://www.luogu.com.cn/problem/P3378">P3378 【模板】堆</a>。</p><h2 id="带入"><a href="#带入" class="headerlink" title="带入"></a>带入</h2><p>让我们复习一下学过的最值问题。  </p><p>($l$ 为数组的长度)</p><ul><li>暴力 时间复杂度 $O(n l)$</li><li>线段树 用不了(无法增删)</li><li>单调队列 用不了(太惨了)</li><li>倍增(ST表) 用不了(只能处理静态的区间最值)</li></ul><p>很显然，没有算法可以AC这道题，我们需要新的算法。</p><h2 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h2><p>我们使用一种叫 堆（优先队列）的数据结构。<br>堆是一棵二叉树，有大根堆和小根堆。<br>大根堆：父节点 $&gt;$ 子节点。<br>小根堆：父节点 $&lt;$ 子节点。<br>此外，堆还是一个<strong>完全二叉树</strong>。<br>那堆如何进行增删查呢？<br>(虽然题目中需要使用小根堆，但这里为了讲解需要，下面都是大根堆)</p><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><p>这是一个大根堆。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/w9kn5qba.png"><br>我们增的步骤如下(例如插入20)。  </p><ol><li>先把数插在最后面。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/sc9tuvbn.png"></li><li>再和父节点交换。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/45iugwib.png"></li></ol><h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><p>由于堆的约束，堆没有太多规律，所以查只会查根节点。<br>例如上面这个堆查询的结果就是 $100$。</p><h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3><p>跟查一样，只能删除根节点，那又该如何操作呢？</p><ol><li>当然先把根节点给删掉。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/jy1g74lk.png">  </li><li>把最后一个节点当做根节点。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/iqub7j21.png"></li><li>选择根节点的子节点中较大（如果是小根堆就较小）的值进行比较。<br>因为 $\max(70,20) &#x3D; 70$ ，所以 $10$ 要和 $70$ 进行比较，不满足，交换。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/lbk197mv.png"><br>因为 $\max(20,30) &#x3D; 30$ ，所以 $10$ 要和 $30$ 进行比较，不满足，交换。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/sg8zd82c.png"><br>因为 $10$ 已经到了最低端，没有子节点，所以结束。</li></ol><p>我们在执行步骤 3 的时候，发现执行完最后一次后，这棵树依然满足堆的特点，为什么呢？<br>这就要跟为什么要选择最大值进行比较有关系了。<br>我们试试用较小的值交换。<br><img src="https://cdn.luogu.com.cn/upload/image_hosting/3ti4nl1g.png"><br>我们发现由于 $70 &gt; 20$ 这个堆不是大根堆，而最大值改除了 $10$ 没有其他问题，所以应该找最大的比较。<br>（你说最大值比较不是有 $10$ 的问题吗，纯属巧合）<br>回答第一个问题，因为每次都在尝试把这个堆变成正常的堆，所以结束了，堆自然就正确了，而且每次最多只有可能有 $10$ 的问题，换完就没有错误了。  </p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>(这里按题目是小根堆)</p><h3 id="定义变量和存储"><a href="#定义变量和存储" class="headerlink" title="定义变量和存储"></a>定义变量和存储</h3><p>如何存储一棵树，很简单，根节点编号为 $1$ ，编号为 $p$ 的点左节点的编号为 $p * 2$，右节点的编号则为 $p * 2 + 1$。<br>将这些升级为速度更快的位运算就为 <code>p &lt;&lt; 1</code> 和 <code>p &lt;&lt; 1 | 1</code>。</p><p>题目的数据范围是 $1 \le n \le 10 ^ 6$，堆又是一个完全二叉树，所以数组只用开 $10 ^ 6$ 就够了。<br>我们还需要一个 $l$，代表当前数组的长度。<br>当然，我们还要一个题目中给的数 $n$。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> tre[<span class="hljs-number">1000010</span>],l,n;<br></code></pre></td></tr></table></figure><h3 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h3><p>我们按照原先增的顺序进行操作。</p><p>先在堆的尾部加上值（添加的值为 $x$）。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">tre[++l] = x;<br></code></pre></td></tr></table></figure><p>再和父节点交换。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>(tre[l] &gt; tre[l / <span class="hljs-number">2</span>])<span class="hljs-comment">//注意，如果tre[l]是右节点的话/2会向下取整，所以不用担心</span><br>    <span class="hljs-built_in">swap</span>(tre[l],tre[l / <span class="hljs-number">2</span>]);<br></code></pre></td></tr></table></figure><p>我们知道，这个过程不止一次，所以需要一个 <code>while</code> 循环。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p = l;<br><span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">1</span> &amp;&amp; tre[p] &lt; tre[p / <span class="hljs-number">2</span>])<br><span class="hljs-built_in">swap</span>(tre[p],tre[p / <span class="hljs-number">2</span>]),p /= <span class="hljs-number">2</span>;<span class="hljs-comment">//注意，如果交换了，p要变为自己的父节点</span><br></code></pre></td></tr></table></figure><p>最后把它封装成函数。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>tre[++l] = x;<br><span class="hljs-type">int</span> p = l;<br><span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">1</span> &amp;&amp; tre[p] &lt; tre[p / <span class="hljs-number">2</span>])<span class="hljs-comment">//没有到顶</span><br><span class="hljs-built_in">swap</span>(tre[p],tre[p / <span class="hljs-number">2</span>]),p /= <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h3><p>直接用返回堆顶的值就行了。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> tre[<span class="hljs-number">1</span>];&#125;<br></code></pre></td></tr></table></figure><h3 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h3><p>按照步骤原先删的步骤进行。</p><p>先把原来的值覆盖。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">tre[<span class="hljs-number">1</span>] = tre[l--];<span class="hljs-comment">//注意要l--</span><br></code></pre></td></tr></table></figure><p>再像增一样弄。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> p = <span class="hljs-number">1</span>,q = p * <span class="hljs-number">2</span>;<span class="hljs-comment">//p始终维护一个子节点最小的值</span><br><span class="hljs-keyword">while</span>(q &lt;= l)<span class="hljs-comment">//还有子节点</span><br>&#123;<br><span class="hljs-keyword">if</span>(q + <span class="hljs-number">1</span> &lt;= l &amp;&amp; tre[q + <span class="hljs-number">1</span>] &lt; tre[q]) q++;<br><span class="hljs-keyword">if</span>(tre[p] &gt; tre[q]) <span class="hljs-built_in">swap</span>(tre[p],tre[q]);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <span class="hljs-comment">//如果不用交换就满足了，直接退出</span><br>p = q,q = p * <span class="hljs-number">2</span>;<span class="hljs-comment">//更新</span><br>&#125;<br></code></pre></td></tr></table></figure><p>封装成函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>tre[<span class="hljs-number">1</span>] = tre[l--];<br><span class="hljs-type">int</span> p = <span class="hljs-number">1</span>,q = p * <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(q &lt;= l)<br>&#123;<br><span class="hljs-keyword">if</span>(q + <span class="hljs-number">1</span> &lt;= l &amp;&amp; tre[q + <span class="hljs-number">1</span>] &lt; tre[q]) q++;<br><span class="hljs-keyword">if</span>(tre[p] &gt; tre[q]) <span class="hljs-built_in">swap</span>(tre[p],tre[q]);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <br>p = q,q = p * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> tre[<span class="hljs-number">1000010</span>],l,n;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function"></span>&#123;<br>tre[++l] = x;<br><span class="hljs-type">int</span> p = l;<br><span class="hljs-keyword">while</span>(p &gt; <span class="hljs-number">1</span> &amp;&amp; tre[p] &lt; tre[p / <span class="hljs-number">2</span>])<br><span class="hljs-built_in">swap</span>(tre[p],tre[p / <span class="hljs-number">2</span>]),p /= <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span></span>&#123;<span class="hljs-keyword">return</span> tre[<span class="hljs-number">1</span>];&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>tre[<span class="hljs-number">1</span>] = tre[l--];<br><span class="hljs-type">int</span> p = <span class="hljs-number">1</span>,q = p * <span class="hljs-number">2</span>;<br><span class="hljs-keyword">while</span>(q &lt;= l)<br>&#123;<br><span class="hljs-keyword">if</span>(q + <span class="hljs-number">1</span> &lt;= l &amp;&amp; tre[q + <span class="hljs-number">1</span>] &lt; tre[q]) q++;<br><span class="hljs-keyword">if</span>(tre[p] &gt; tre[q]) <span class="hljs-built_in">swap</span>(tre[p],tre[q]);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>; <br>p = q,q = p * <span class="hljs-number">2</span>;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span>(n--)<br>&#123;<br><span class="hljs-type">int</span> op,x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;op);<br><span class="hljs-keyword">if</span>(op == <span class="hljs-number">1</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;x),<span class="hljs-built_in">push</span>(x);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(op == <span class="hljs-number">2</span>) cout &lt;&lt; <span class="hljs-built_in">top</span>() &lt;&lt; endl;<br><span class="hljs-keyword">else</span> <span class="hljs-built_in">pop</span>(); <br>&#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="STL-做法"><a href="#STL-做法" class="headerlink" title="STL 做法"></a>STL 做法</h3><p>堆也被 STL 封装成模版了。  </p><p>模版名叫 <code>priority_queue</code>。<br>用法是这样的。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;你的类型&gt; q;<span class="hljs-comment">//默认大根堆</span><br></code></pre></td></tr></table></figure><p>如果你要小根堆请这样输入。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">priority_queue&lt;你的类型,vector&lt;你的类型&gt;,greater&lt;你的类型&gt;&gt; q;<span class="hljs-comment">//注意最后的&gt;&gt;，中间不加空格并且不开C++11会以为是右移</span><br></code></pre></td></tr></table></figure><p>比如我有一个结构体用来封装请在中间插入这样一个函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">bool</span> <span class="hljs-keyword">operator</span> &lt; (<span class="hljs-type">const</span> &amp;结构体名称 y) <span class="hljs-type">const</span><br>&#123;<br>    你的做法<br>&#125;<br></code></pre></td></tr></table></figure><p>它拥有 <code>push</code>，<code>top</code>，<code>pop</code> 等函数，用法如下。  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp">q.<span class="hljs-built_in">push</span>(x);<span class="hljs-comment">//向堆里插入x</span><br>q.<span class="hljs-built_in">top</span>();<span class="hljs-comment">//获取堆首的值</span><br>q.<span class="hljs-built_in">pop</span>();<span class="hljs-comment">//删除堆首</span><br></code></pre></td></tr></table></figure><p>最终代码：  </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br><span class="hljs-type">int</span> n;<br>cin &gt;&gt; n;<br><span class="hljs-keyword">while</span> (n--)<br>&#123;<br><span class="hljs-type">int</span> op, x;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;op);<br><span class="hljs-keyword">if</span> (op == <span class="hljs-number">1</span>) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x), q.<span class="hljs-built_in">push</span>(x);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) cout &lt;&lt; q.<span class="hljs-built_in">top</span>() &lt;&lt; endl;<br><span class="hljs-keyword">else</span> q.<span class="hljs-built_in">pop</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="好题推荐"><a href="#好题推荐" class="headerlink" title="好题推荐"></a>好题推荐</h1><table><thead><tr><th align="center">题号</th><th align="center">题目</th><th align="center">难度</th></tr></thead><tbody><tr><td align="center">P3378</td><td align="center"><a href="https://www.luogu.com.cn/problem/P3378">【模板】堆</a></td><td align="center">普及−</td></tr><tr><td align="center">P1801</td><td align="center"><a href="https://www.luogu.com.cn/problem/P1801">黑匣子</a></td><td align="center">普及+&#x2F;提高</td></tr><tr><td align="center">P1168</td><td align="center"><a href="https://www.luogu.com.cn/problem/P1168">中位数</a></td><td align="center">普及+&#x2F;提高</td></tr><tr><td align="center">P1752</td><td align="center"><a href="https://www.luogu.com.cn/problem/P1752">点菜</a></td><td align="center">省选&#x2F;NOI−</td></tr><tr><td align="center">P2048</td><td align="center"><a href="https://www.luogu.com.cn/problem/P2048">[NOI2010] 超级钢琴</a></td><td align="center">省选&#x2F;NOI−</td></tr><tr><td align="center">P3644</td><td align="center"><a href="https://www.luogu.com.cn/problem/P3644">[APIO2015] 巴邻旁之桥</a></td><td align="center">省选&#x2F;NOI−</td></tr></tbody></table><h1 id="修改记录"><a href="#修改记录" class="headerlink" title="修改记录"></a>修改记录</h1><p>11&#x2F;24 修改了句子末尾应添加句号，且全文使用的句号应一致的问题。</p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
